{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "823e77d1-01db-494d-b55d-7bd925658348",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.express as px\n",
    "import plotly.io as pio\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "from nltk.sentiment.vader import SentimentIntensityAnalyzer\n",
    "import nltk\n",
    "import webbrowser\n",
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "73edace9-73ae-426f-a51e-220271a0f710",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[nltk_data] Downloading package vader_lexicon to\n",
      "[nltk_data]     C:\\Users\\KIIT\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package vader_lexicon is already up-to-date!\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "nltk.download('vader_lexicon')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8d1affac-8ce1-4f8b-9b3b-0627164286c6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 1: Load the Dataset\n",
    "apps_df = pd.read_csv('googleplaystore.csv')\n",
    "reviews_df = pd.read_csv('googleplaystore_user_reviews.csv')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "ab8197a5-4dd4-4cfd-b6ac-b715d4ccdef5",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\KIIT\\AppData\\Local\\Temp\\ipykernel_13668\\3675673569.py:4: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\n",
      "The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n",
      "\n",
      "For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n",
      "\n",
      "\n",
      "  apps_df[column].fillna(apps_df[column].mode()[0], inplace=True)\n"
     ]
    }
   ],
   "source": [
    "# Step 2: Data Cleaning\n",
    "apps_df = apps_df.dropna(subset=['Rating'])\n",
    "for column in apps_df.columns:\n",
    "    apps_df[column].fillna(apps_df[column].mode()[0], inplace=True)\n",
    "apps_df.drop_duplicates(inplace=True)\n",
    "apps_df = apps_df[apps_df['Rating'] <= 5]\n",
    "reviews_df.dropna(subset=['Translated_Review'], inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "389b1f7a-f9c6-4fe0-8dbb-2930773c50c7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Merge datasets on 'App' and handle non-matching apps\n",
    "merged_df = pd.merge(apps_df, reviews_df, on='App', how='inner')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "3c4ecaf4-44cc-4707-b127-df42aeffc275",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 3: Data Transformation\n",
    "\n",
    "# Convert 'Reviews' to integer\n",
    "apps_df['Reviews'] = apps_df['Reviews'].astype(int)\n",
    "\n",
    "# Ensure 'Installs' is treated as string before replacing commas and plus signs\n",
    "apps_df['Installs'] = apps_df['Installs'].astype(str).str.replace(',', '').str.replace('+', '').astype(int)\n",
    "\n",
    "# Ensure 'Price' is treated as string before removing the dollar sign and converting to float\n",
    "apps_df['Price'] = apps_df['Price'].astype(str).str.replace('$', '').astype(float)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "960b5442-d2e9-40a6-99ef-ef2c0f05e686",
   "metadata": {},
   "outputs": [],
   "source": [
    "def convert_size(size):\n",
    "    if 'M' in size:\n",
    "        return float(size.replace('M', ''))\n",
    "    elif 'k' in size:\n",
    "        return float(size.replace('k', '')) / 1024\n",
    "    else:\n",
    "        return np.nan"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "1cff8a81-d874-416f-a82c-cec72d5b7bb0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "\n",
    "def convert_size(size):\n",
    "    if isinstance(size, str):  # Only process strings\n",
    "        if 'M' in size:\n",
    "            return float(size.replace('M', ''))  # Convert MB to float\n",
    "        elif 'k' in size:\n",
    "            return float(size.replace('k', '')) / 1024  # Convert KB to MB\n",
    "        else:\n",
    "            return np.nan  # If no unit is present, return NaN (or handle accordingly)\n",
    "    elif isinstance(size, (int, float)):  # Handle numerical values\n",
    "        return size  # Return the size as is if it's a number\n",
    "    return np.nan  # Return NaN if the size is neither a string nor a number\n",
    "\n",
    "# Apply the function to the 'Size' column\n",
    "apps_df['Size'] = apps_df['Size'].apply(convert_size)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "a934b4f5-b806-4bce-b196-dd8e9f2d7c5b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Add log_installs and log_reviews columns\n",
    "apps_df['Log_Installs'] = np.log1p(apps_df['Installs'])\n",
    "apps_df['Log_Reviews'] = np.log1p(apps_df['Reviews'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "ec3314c2-f6c3-43f9-b6e6-d6cc6e5edc19",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Add Rating Group column\n",
    "def rating_group(rating):\n",
    "    if rating >= 4:\n",
    "        return 'Top rated'\n",
    "    elif rating >= 3:\n",
    "        return 'Above average'\n",
    "    elif rating >= 2:\n",
    "        return 'Average'\n",
    "    else:\n",
    "        return 'Below average'\n",
    "\n",
    "apps_df['Rating_Group'] = apps_df['Rating'].apply(rating_group)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "8252405c-1180-4efa-ba0d-7ecddeedc6c4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Add Revenue column\n",
    "apps_df['Revenue'] = apps_df['Price'] * apps_df['Installs']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "3ce80332-1236-4e3a-ab59-2e6c5b31943a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Add Revenue column\n",
    "apps_df['Revenue'] = apps_df['Price'] * apps_df['Installs']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "9d622da1-c60c-4c80-9368-d1e07e64bc55",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Extract year from 'Last Updated' and create 'Year' column\n",
    "apps_df['Last Updated'] = pd.to_datetime(apps_df['Last Updated'], errors='coerce')\n",
    "apps_df['Year'] = apps_df['Last Updated'].dt.year"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "8b6ca75c-f28c-492e-b77d-f44de9071513",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Index(['App', 'Translated_Review', 'Sentiment', 'Sentiment_Polarity',\n",
      "       'Sentiment_Subjectivity'],\n",
      "      dtype='object')\n"
     ]
    }
   ],
   "source": [
    "print(reviews_df.columns)  # This will display the list of columns in reviews_df\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "eed8a8f5-42cc-4d8a-b359-8e925a97b800",
   "metadata": {},
   "outputs": [],
   "source": [
    "if 'Sentiment' in reviews_df.columns:\n",
    "    sentiment_counts = reviews_df['Sentiment'].value_counts()\n",
    "    fig4 = px.bar(\n",
    "        x=sentiment_counts.index,\n",
    "        y=sentiment_counts.values,\n",
    "        labels={'x': 'Sentiment', 'y': 'Count'},\n",
    "        title='Sentiment Distribution',\n",
    "        color=sentiment_counts.index,\n",
    "        color_discrete_sequence=px.colors.sequential.RdPu,\n",
    "        width=plot_width,\n",
    "        height=plot_height\n",
    "    )\n",
    "    fig4.update_layout(\n",
    "        plot_bgcolor=plot_bg_color,\n",
    "        paper_bgcolor=plot_bg_color,\n",
    "        font_color=text_color,\n",
    "        title_font=title_font,\n",
    "        xaxis=dict(title_font=axis_font),\n",
    "        yaxis=dict(title_font=axis_font),\n",
    "        margin=dict(l=10, r=10, t=30, b=10)\n",
    "    )\n",
    "    fig4.update_traces(marker=dict(line=dict(color=text_color, width=1)))\n",
    "    save_plot_as_html(fig4, \"sentiment_distribution.html\", \"Sentiment distribution shows the breakdown of reviews into positive, neutral, and negative categories.\")\n",
    "else:\n",
    "    print(\"Sentiment column not found in the reviews dataframe.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "28dd48d8-9936-401a-9054-5488273ed5b7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import plotly.express as px\n",
    "\n",
    "# Define the path for your HTML files\n",
    "html_files_path = \"./\"\n",
    "\n",
    "# Make sure the directory exists\n",
    "if not os.path.exists(html_files_path):\n",
    "    os.makedirs(html_files_path)\n",
    "\n",
    "# Initialize plot_containers\n",
    "plot_containers = \"\"\n",
    "\n",
    "# Save each Plotly figure to an HTML file\n",
    "def save_plot_as_html(fig, filename, insight):\n",
    "    global plot_containers\n",
    "    filepath = os.path.join(html_files_path, filename)\n",
    "    html_content = pio.to_html(fig, full_html=False, include_plotlyjs='inline')\n",
    "    # Append the plot and its insight to plot_containers\n",
    "    plot_containers += f\"\"\"\n",
    "    <div class=\"plot-container\" id=\"{filename}\" onclick=\"openPlot('{filename}')\">\n",
    "        <div class=\"plot\">{html_content}</div>\n",
    "        <div class=\"insights\">{insight}</div>\n",
    "    </div>\n",
    "    \"\"\"\n",
    "    fig.write_html(filepath, full_html=False, include_plotlyjs='inline')\n",
    "\n",
    "# Define your plots\n",
    "plot_width = 400\n",
    "plot_height = 300\n",
    "plot_bg_color = 'black'\n",
    "text_color = 'white'\n",
    "title_font = {'size': 16}\n",
    "axis_font = {'size': 12}\n",
    "\n",
    "# Category Analysis Plot\n",
    "category_counts = apps_df['Category'].value_counts().nlargest(10)\n",
    "fig1 = px.bar(\n",
    "    x=category_counts.index,\n",
    "    y=category_counts.values,\n",
    "    labels={'x': 'Category', 'y': 'Count'},\n",
    "    title='Top Categories on Play Store',\n",
    "    color=category_counts.index,\n",
    "    color_discrete_sequence=px.colors.sequential.Plasma,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig1.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "fig1.update_traces(marker=dict(line=dict(color=text_color, width=1)))\n",
    "save_plot_as_html(fig1, \"category_analysis.html\", \"The top categories on the Play Store are dominated by tools, entertainment, and productivity apps. This suggests users are looking for apps that either provide utility or offer leisure activities.\")\n",
    "\n",
    "# Type Analysis Plot\n",
    "type_counts = apps_df['Type'].value_counts()\n",
    "fig2 = px.pie(\n",
    "    values=type_counts.values,\n",
    "    names=type_counts.index,\n",
    "    title='App Type Distribution',\n",
    "    color_discrete_sequence=px.colors.sequential.RdBu,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig2.update_traces(textposition='inside', textinfo='percent+label')\n",
    "fig2.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "save_plot_as_html(fig2, \"type_analysis.html\", \"Most apps on the Play Store are free, indicating a strategy to attract users first and monetize through ads or in-app purchases.\")\n",
    "\n",
    "# Rating Distribution Plot\n",
    "fig3 = px.histogram(\n",
    "    apps_df,\n",
    "    x='Rating',\n",
    "    nbins=20,\n",
    "    title='Rating Distribution',\n",
    "    color_discrete_sequence=['#636EFA'],\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig3.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "save_plot_as_html(fig3, \"rating_distribution.html\", \"Ratings are skewed towards higher values, suggesting that most apps are rated favorably by users.\")\n",
    "\n",
    "if 'Sentiment' in reviews_df.columns:\n",
    "    sentiment_counts = reviews_df['Sentiment'].value_counts()\n",
    "    fig4 = px.bar(\n",
    "        x=sentiment_counts.index,\n",
    "        y=sentiment_counts.values,\n",
    "        labels={'x': 'Sentiment', 'y': 'Count'},\n",
    "        title='Sentiment Distribution',\n",
    "        color=sentiment_counts.index,\n",
    "        color_discrete_sequence=px.colors.sequential.RdPu,\n",
    "        width=plot_width,\n",
    "        height=plot_height\n",
    "    )\n",
    "    fig4.update_layout(\n",
    "        plot_bgcolor=plot_bg_color,\n",
    "        paper_bgcolor=plot_bg_color,\n",
    "        font_color=text_color,\n",
    "        title_font=title_font,\n",
    "        xaxis=dict(title_font=axis_font),\n",
    "        yaxis=dict(title_font=axis_font),\n",
    "        margin=dict(l=10, r=10, t=30, b=10)\n",
    "    )\n",
    "    fig4.update_traces(marker=dict(line=dict(color=text_color, width=1)))\n",
    "    save_plot_as_html(fig4, \"sentiment_distribution.html\", \"Sentiment distribution shows the breakdown of reviews into positive, neutral, and negative categories.\")\n",
    "else:\n",
    "    print(\"Sentiment column not found in the reviews dataframe.\")\n",
    "\n",
    "\n",
    "# Installs by Category Plot\n",
    "installs_by_category = apps_df.groupby('Category')['Installs'].sum().nlargest(10)\n",
    "fig5 = px.bar(\n",
    "    x=installs_by_category.values,\n",
    "    y=installs_by_category.index,\n",
    "    orientation='h',\n",
    "    labels={'x': 'Installs', 'y': 'Category'},\n",
    "    title='Installs by Category',\n",
    "    color=installs_by_category.index,\n",
    "    color_discrete_sequence=px.colors.sequential.Blues,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig5.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "fig5.update_traces(marker=dict(line=dict(color=text_color, width=1)))\n",
    "save_plot_as_html(fig5, \"installs_by_category.html\", \"The categories with the most installs are social and communication apps, which reflects their broad appeal and daily usage.\")\n",
    "\n",
    "# Updates Per Year Plot\n",
    "updates_per_year = apps_df['Last Updated'].dt.year.value_counts().sort_index()\n",
    "fig6 = px.line(\n",
    "    x=updates_per_year.index,\n",
    "    y=updates_per_year.values,\n",
    "    labels={'x': 'Year', 'y': 'Number of Updates'},\n",
    "    title='Number of Updates Over the Years',\n",
    "    color_discrete_sequence=['#AB63FA'],\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig6.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "save_plot_as_html(fig6, \"updates_per_year.html\", \"Updates have been increasing over the years, showing that developers are actively maintaining and improving their apps.\")\n",
    "\n",
    "# Revenue by Category Plot\n",
    "revenue_by_category = apps_df.groupby('Category')['Revenue'].sum().nlargest(10)\n",
    "fig7 = px.bar(\n",
    "    x=revenue_by_category.index,\n",
    "    y=revenue_by_category.values,\n",
    "    labels={'x': 'Category', 'y': 'Revenue'},\n",
    "    title='Revenue by Category',\n",
    "    color=revenue_by_category.index,\n",
    "    color_discrete_sequence=px.colors.sequential.Greens,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig7.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "fig7.update_traces(marker=dict(line=dict(color=text_color, width=1)))\n",
    "save_plot_as_html(fig7, \"revenue_by_category.html\", \"Categories such as Business and Productivity lead in revenue generation, indicating their monetization potential.\")\n",
    "\n",
    "# Genre Count Plot\n",
    "genre_counts = apps_df['Genres'].str.split(';', expand=True).stack().value_counts().nlargest(10)\n",
    "fig8 = px.bar(\n",
    "    x=genre_counts.index,\n",
    "    y=genre_counts.values,\n",
    "    labels={'x': 'Genre', 'y': 'Count'},\n",
    "    title='Top Genres',\n",
    "    color=genre_counts.index,\n",
    "    color_discrete_sequence=px.colors.sequential.OrRd,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig8.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "fig8.update_traces(marker=dict(line=dict(color=text_color, width=1)))\n",
    "save_plot_as_html(fig8, \"genres_counts.html\", \"Action and Casual genres are the most common, reflecting users' preference for engaging and easy-to-play games.\")\n",
    "\n",
    "# Impact of Last Update on Rating\n",
    "fig9 = px.scatter(\n",
    "    apps_df,\n",
    "    x='Last Updated',\n",
    "    y='Rating',\n",
    "    color='Type',\n",
    "    title='Impact of Last Update on Rating',\n",
    "    color_discrete_sequence=px.colors.qualitative.Vivid,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig9.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "save_plot_as_html(fig9, \"update_on_rating.html\", \"The scatter plot shows a weak correlation between the last update date and ratings, suggesting that more frequent updates don't always result in better ratings.\")\n",
    "\n",
    "# Ratings for Paid vs Free Apps\n",
    "fig10 = px.box(\n",
    "    apps_df,\n",
    "    x='Type',\n",
    "    y='Rating',\n",
    "    color='Type',\n",
    "    title='Ratings for Paid vs Free Apps',\n",
    "    color_discrete_sequence=px.colors.qualitative.Pastel,\n",
    "    width=plot_width,\n",
    "    height=plot_height\n",
    ")\n",
    "fig10.update_layout(\n",
    "    plot_bgcolor=plot_bg_color,\n",
    "    paper_bgcolor=plot_bg_color,\n",
    "    font_color=text_color,\n",
    "    title_font=title_font,\n",
    "    xaxis=dict(title_font=axis_font),\n",
    "    yaxis=dict(title_font=axis_font),\n",
    "    margin=dict(l=10, r=10, t=30, b=10)\n",
    ")\n",
    "save_plot_as_html(fig10, \"ratings_paid_free.html\", \"Paid apps generally have higher ratings compared to free apps, suggesting that users expect higher quality from apps they pay for.\")\n",
    "\n",
    "# Split plot_containers to handle the last plot properly\n",
    "plot_containers_split = plot_containers.split('</div>')\n",
    "if len(plot_containers_split) > 1:\n",
    "    final_plot = plot_containers_split[-2] + '</div>'\n",
    "else:\n",
    "    final_plot = plot_containers  # Use plot_containers as default if splitting isn't sufficient\n",
    "\n",
    "# HTML template for the dashboard\n",
    "dashboard_html = \"\"\"\n",
    "<!DOCTYPE html>\n",
    "<html lang=\"en\">\n",
    "<head>\n",
    "    <meta charset=\"UTF-8\">\n",
    "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n",
    "    <title>Google Play Store Reviews Analytics</title>\n",
    "    <style>\n",
    "        body {{\n",
    "            font-family: Arial, sans-serif;\n",
    "            background-color: #333;\n",
    "            color: #fff;\n",
    "            margin: 0;\n",
    "            padding: 0;\n",
    "        }}\n",
    "        .header {{\n",
    "            display: flex;\n",
    "            align-items: center;\n",
    "            justify-content: center;\n",
    "            padding: 20px;\n",
    "            background-color: #444;\n",
    "        }}\n",
    "        .header img {{\n",
    "            margin: 0 10px;\n",
    "            height: 50px;\n",
    "        }}\n",
    "        .container {{\n",
    "            display: flex;\n",
    "            flex-wrap: wrap;\n",
    "            justify-content: center;\n",
    "            padding: 20px;\n",
    "        }}\n",
    "        .plot-container {{\n",
    "            border: 2px solid #555;\n",
    "            margin: 10px;\n",
    "            padding: 10px;\n",
    "            width: {plot_width}px;\n",
    "            height: {plot_height}px;\n",
    "            overflow: hidden;\n",
    "            position: relative;\n",
    "            cursor: pointer;\n",
    "        }}\n",
    "        .insights {{\n",
    "            display: none;\n",
    "            position: absolute;\n",
    "            right: 10px;\n",
    "            top: 10px;\n",
    "            background-color: rgba(0, 0, 0, 0.7);\n",
    "            padding: 5px;\n",
    "            border-radius: 5px;\n",
    "            color: #fff;\n",
    "        }}\n",
    "        .plot-container:hover .insights {{\n",
    "            display: block;\n",
    "        }}\n",
    "    </style>\n",
    "    <script>\n",
    "        function openPlot(filename) {{\n",
    "            window.open(filename, '_blank');\n",
    "        }}\n",
    "    </script>\n",
    "</head>\n",
    "<body>\n",
    "    <div class=\"header\">\n",
    "        <img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Logo_2013_Google.png/800px-Logo_2013_Google.png\" alt=\"Google Logo\">\n",
    "        <h1>Google Play Store Reviews Analytics</h1>\n",
    "        <img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Google_Play_Store_badge_EN.svg/1024px-Google_Play_Store_badge_EN.svg.png\" alt=\"Google Play Store Logo\">\n",
    "    </div>\n",
    "    <div class=\"container\">\n",
    "        {plots}\n",
    "    </div>\n",
    "</body>\n",
    "</html>\n",
    "\"\"\"\n",
    "\n",
    "# Use these containers to fill in your dashboard HTML\n",
    "final_html = dashboard_html.format(plots=plot_containers, plot_width=plot_width, plot_height=plot_height)\n",
    "\n",
    "# Save the final dashboard to an HTML file\n",
    "dashboard_path = os.path.join(html_files_path, \"dashboard.html\")\n",
    "with open(dashboard_path, \"w\", encoding=\"utf-8\") as f:\n",
    "    f.write(final_html)\n",
    "\n",
    "# Automatically open the generated HTML file in a web browser\n",
    "webbrowser.open('file://' + os.path.realpath(dashboard_path))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f4eda03-bb8d-4362-a85d-43fe0f55cc18",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
